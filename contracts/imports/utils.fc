(int) power(int x, int n) {
    if (n == 1) {
        return x;
    }
    if (n == 0) {
        return 1;
    }

    int x1 = power(x, (n / 2));
    x1 *= x1;
    if (n % 2) {
        x1 *= x;
    }
    return x1;
}

;; Decodings:
;;   3 bits - base_factor, where base = 10/8
;;   4 bits - power of 10
;;
;; Examples:
;;  0x38 -> 00111 000 ->  10,000,000 (0.01 TON)
;;  0x39 -> 00111 001 ->  12,500,000 (0.0125 TON)
;;  0x3A -> 00111 010 ->  25,000,000 (0.025 TON)
;;  0x3C -> 00111 100 ->  50,000,000 (0.05 TON)
;;  0x3E -> 00111 110 ->  75,000,000 (0.075 TON)
;;  0x40 -> 01000 000 -> 100,000,000 (0.1 TON)
;;

(int) unpack_qint(int qnum) {
    qnum &= 0x7F;
    if (qnum == 0) {
        return 0;
    }

    int num = ((qnum & 7) * 10);
    num = num ? num : 8;
    return (num * power(10, qnum >> 3)) >> 3;
}

(int) random_uint64() {
    return random() & 0xFFFFFFFFFFFFFFFF;
}

(int) random_uint32() {
    return random() & 0xFFFFFFFF;
}

;; BCD encoded date mask
;; 4 octets - year; 2 Octets - month; 2 octets - day; 0x00 - means unspecified or unknown
;;   0x20250100 - means 2025-01-*
;;   0x20250000 - means 2025-*
(slice) date_mask_to_string(int n) {
    builder string = begin_cell();
    
    if ((n >> 16) & 0xFFFF) {
        int i = 32;
        do {
            i -= 4;
            string~store_uint(((n >> i) & 0xF) + 48, 8);
            if ((i == 16) | (i == 8)) {
                if ((n >> (i - 8)) & 0xFF) {
                    string~store_uint(45, 8); ;; "-"
                }
                else {
                    string~store_uint(42, 8); ;; "*"
                    i = 0;
                }
            }
        } until (i == 0);
    }
    else {
        string~store_uint(42, 8); ;; "*"
    }

    return string.end_cell().begin_parse();
}

;; BCD 5-bits encoded 2-letter english char code
;;  used for ISO 639 two letter language code or ISO 3166-1 alpha-2 code
(slice) bcd2c_to_string(int n) {
    builder string = begin_cell();
    string~store_uint(((n >> 5) & 0x1F) + 65, 8);
    string~store_uint((n & 0x1F) + 65, 8);
    return string.end_cell().begin_parse();
}